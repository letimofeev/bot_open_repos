<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>Commander API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Commander</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from Ban import *
from Interpreter import *
from Configuration import Configuration
from Filter import BadWordsFilter
import datetime


class Answerer:
    &#34;&#34;&#34;Класс для получения ответа на полученное сообщение

    Attributes
    ----------
    FileLoader
        Класс для доступа к файлам и их обновления
    Links
        Класс для получения ссылок на занятия из файла
    Schedule
        Класс для получения расписания
    Messages
        Класс для хранения и получения зарезервированных ответов и сообщений
    Storage
        Класс для взаимодействия с файлами в хранилище
    QueryResponder
        Класс для ответа на запросы
    GraphBuilder
        Класс для построения графиков
    Keyboard
        Класс клавиатуры
    Saver
        Класс для логирования
    prefix: str
        Префикс для названия файлов клавиатур и логов
    __answers: dict, default None
        Словарь последних сообщений для запоминания предыдущих ответов
    &#34;&#34;&#34;
    def __init__(self, answers=None):
        if answers is None:
            answers = {}
        self.__answers = answers
        self.FileLoader = Configuration.FileLoader
        self.Links = Configuration.Links
        self.Schedule = Configuration.Schedule
        self.Messages = Configuration.Messages
        self.Storage = Configuration.Storage
        self.QueryResponder = Configuration.QueryResponder
        self.GraphBuilder = Configuration.GraphBuilder
        self.Keyboard = Configuration.Keyboard
        self.prefix = Configuration.prefix
        self.Saver = Configuration.Saver

    def get_teacher_info(self, peer_id: int, text: str, name: str, surname: str, admins: list) -&gt; dict:
        &#34;&#34;&#34;
        Получение информации о пользователе, обучившего бота

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        name: str
            Имя пользователя
        surname: str
            Фамилия пользователя
        admins: list
            Список id администраторов

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;who added &#34;)
        if text[:prefix_size] == &#34;who added &#34; and peer_id in admins:
            phrase = text[prefix_size:]
            custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
            if phrase in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
                customer_id = int(self.Messages(custom=custom_file).get_teacher_id(phrase))
                answer = self.Messages(custom=custom_file).get_answer_custom(phrase)
                if surname is None:
                    surname = &#34;None&#34;
                return {&#34;answer&#34;: (&#39;Имя: &#39; + name + &#39;\n&#39; +
                                   &#39;Фамилия: &#39; + surname + &#39;\n&#39; +
                                   &#39;id: &#39; + str(customer_id) + &#39;\n&#39; +
                                   &#34;Установленный ответ на сообщение: &#34; + answer)}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_command(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение ответа на команду

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        commands_file = self.FileLoader(self.Storage).get_csv(file_name=&#39;commands&#39;)
        if text in list(self.Messages(commands=commands_file).commands):
            return {&#34;answer&#34;: self.Messages(commands=commands_file).get_answer_command(text)}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_links(self, peer_id: int, text: str, course: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение ссылки на занятие

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        course: str
            Номер курса

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

            По ключу &#34;keyboard&#34; хранится клавиатура для сообщения
        &#34;&#34;&#34;
        text = text.lower()
        if course is None:
            return {&#34;answer&#34;: False}
        if text == &#39;лекции&#39;:
            self.__answers.update({peer_id: [text]})
            return {&#34;last_messages&#34;: self.__answers,
                    &#34;answer&#34;: &#39;Выберите предмет:&#39;,
                    &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix+f&#34;lectures_keyboard{course}.json&#34;)}
        links_file = self.FileLoader(self.Storage).get_csv(file_name=f&#39;{course} курс&#39;, folder_name=&#39;Ссылки на занятия&#39;)
        if text in self.Links(links_file).get_subj_list() and self.__answers.get(peer_id) is not None:
            if len(self.__answers[peer_id]):
                if self.__answers[peer_id][0] == &#39;лекции&#39;:
                    self.__answers[peer_id].clear()
                    return {&#34;last_messages&#34;: self.__answers, &#34;answer&#34;: self.Links(links_file).get_subj_link(text)}
        return {&#34;last_messages&#34;: self.__answers, &#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_schedule(self, peer_id: int, text: str, course: str, group: int) -&gt; dict:
        &#34;&#34;&#34;
        Получение расписания

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        course: str
            Номер курса
        group: int
            Номер группы

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

            По ключу &#34;keyboard&#34; хранится клавиатура для сообщения
        &#34;&#34;&#34;
        text = text.lower()
        if course is None or group is None:
            return {&#34;answer&#34;: False}
        if text == &#39;расписание&#39;:
            self.__answers.update({peer_id: [text]})
            return {&#34;last_messages&#34;: self.__answers,
                    &#34;answer&#34;: &#39;Выберите день недели:&#39;,
                    &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix+&#34;days_keyboard.json&#34;)}
        schedule_file = self.FileLoader(self.Storage).get_excel(file_name=&#39;Raspisanie_VESNA_2021&#39;)
        if text in self.Messages().get_days() and self.__answers.get(peer_id) is not None:
            if len(self.__answers[peer_id]):
                if self.__answers[peer_id][0] == &#39;расписание&#39;:
                    self.__answers[peer_id].clear()
                    return {&#34;last_messages&#34;: self.__answers,
                            &#34;answer&#34;: self.Schedule(self.Messages, schedule_file).get_schedule_str(f&#39;{course} курс&#39;, group, text)}
        return {&#34;last_messages&#34;: self.__answers, &#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_text(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение ответа на текстовое сообщение

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
        if text in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
            return {&#34;answer&#34;: self.Messages(custom=custom_file).get_answer_custom(text)}
        return {&#34;answer&#34;: False}

    def delete_answer_text(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Удаление установленного пользователем ответа на сообщение

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;delete &#34;)
        if text[:prefix_size] == &#34;delete &#34; and peer_id in admins:
            phrase = text[prefix_size:]
            custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
            if phrase in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
                logs[&#39;teach&#39;].clear(conditions={&#39;Q&#39;: phrase})
                self.FileLoader().update_csv(self.prefix+&#34;teach&#34;, logs[&#34;teach&#34;].data)
                return {&#34;answer&#34;: f&#39;Ответ на сообщение &#34;{phrase}&#34; удален&#39;}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_photo(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение изображения в ответ на текстовое сообщение

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;photo_link&#34; хранится bool переменная, если True - в &#34;answer&#34; ссылка на изображение
        &#34;&#34;&#34;
        text = text.lower()
        photo_links_file = self.FileLoader(self.Storage).get_csv(file_name=&#39;photo_links&#39;)
        if text in list(self.Messages(photo_links=photo_links_file).photos):
            return {&#34;answer&#34;: self.Messages(photo_links=photo_links_file).get_answer_photo(text), &#34;photo_link&#34;: True}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_query(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение ответа на запрос

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;запрос &#34;)
        if text[:prefix_size] == &#34;запрос &#34;:
            query_text = text[prefix_size:]
            answer = self.QueryResponder().query(query_text)
            if answer:
                return {&#34;answer&#34;: answer}
            else:
                return {&#34;answer&#34;: &#34;Я не смог обработать твой вопрос, задай другой&#34;}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_graph(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение графика функции

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;photo_file&#34; хранится название jpg файла с графиком
        &#34;&#34;&#34;
        try:
            text = text.lower()
            prefix_size = len(&#34;график &#34;)
            if text[:prefix_size] == &#34;график &#34;:
                dimension = text[prefix_size]
                if not (dimension == &#39;2&#39; or dimension == &#39;3&#39;):
                    return {&#34;answer&#34;: &#34;Неверная размерность&#34;}
                func = text[10:]
                self.GraphBuilder().save_plot(func, int(dimension), &#39;graph&#39;)
                return {&#34;answer&#34;: f&#34;График функции {func}&#34;, &#34;photo_file&#34;: &#34;graph.jpg&#34;}
            return {&#34;answer&#34;: False}
        except KeyError:
            return {&#34;answer&#34;: &#34;Я не смог построить этот график, попробуй другой&#34;}

    @AccessLimiter.whitelist_check(Configuration)
    def get_answer_code(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение результата выполнения кода

        Функция доступна только пользователям в whitelist&#39;е

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        prefix_size = len(&#34;code &#34;)
        if text[:prefix_size] == &#34;code &#34;:
            language = text[prefix_size:]
            if not (language == &#39;php&#39; or language == &#39;python&#39;):
                return {&#34;answer&#34;: &#34;Выполнять программы на этом языке я не умею&#34;}
            text = &#34;code&#34;
            self.__answers.update({peer_id: [text]})
            self.__answers[peer_id].append(language)
            return {&#34;answer&#34;: f&#34;Введите код на {language} (для питона отступы пишите через \\t)&#34;,
                    &#34;last_messages&#34;: self.__answers}

        elif self.__answers.get(peer_id) is not None:
            if len(self.__answers[peer_id]) == 2 and self.__answers[peer_id][0] == &#34;code&#34;:
                self.__answers[peer_id].append(text)
                return {&#34;answer&#34;: &#34;Введите аргументы для программы через пробел (если аргументов нет введите no args&#34;,
                        &#34;last_messages&#34;: self.__answers}

            if len(self.__answers[peer_id]) == 3 and self.__answers[peer_id][0] == &#34;code&#34;:
                self.__answers[peer_id].append(text)
                if text == &#39;no args&#39;:
                    args = &#39;&#39;
                else:
                    args = self.__answers[peer_id][3]
                language, code = self.__answers[peer_id][1], self.__answers[peer_id][2]
                if language == &#39;php&#39;:
                    prefix, type_ = &#39;&lt;?php\n&#39;, &#39;.php&#39;
                else:
                    language = Configuration.python_version
                    prefix, type_ = &#39;import sys\n&#39;, &#39;.py&#39;
                executor = Interpreter(language, type_, prefix)
                result = executor.execute_code(code, args)
                self.__answers[peer_id].clear()
                if not result:
                    return {&#34;answer&#34;: &#34;Программа вернула пустую строку&#34;}
                else:
                    return {&#34;answer&#34;: result, &#34;last_messages&#34;: self.__answers}
        return {&#34;answer&#34;: False}

    def add_to_whitelist(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Добавления пользователя в whitelist

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;whitelist add &#34;)
        if text[:prefix_size] == &#34;whitelist add &#34; and peer_id in admins:
            user_id = int(text[prefix_size:])
            logs[&#34;whitelist&#34;].update(user_id)
            self.FileLoader().update_csv(self.prefix+&#34;whitelist&#34;, logs[&#34;whitelist&#34;].data)
            return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} добавлен в whitelist&#34;}
        return {&#34;answer&#34;: False}

    def delete_from_whitelist(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Удаление пользователя из whitelist

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;whitelist delete &#34;)
        if text[:prefix_size] == &#34;whitelist delete &#34; and peer_id in admins:
            user_id = int(text[prefix_size:])
            if not len(logs[&#34;whitelist&#34;].data[logs[&#34;whitelist&#34;].data[&#34;user_id&#34;] == user_id].values):
                return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} не был в whitelist&#39;е&#34;}
            logs[&#39;whitelist&#39;].clear(conditions={&#39;user_id&#39;: user_id})
            self.FileLoader().update_csv(self.prefix+&#34;whitelist&#34;, logs[&#34;whitelist&#34;].data)
            return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} удален из whitelist&#39;a&#34;}
        return {&#34;answer&#34;: False}

    def ban(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Добавления пользователя в ban list

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower().split(&#39; &#39;)
        if text[0] == &#39;ban&#39; and peer_id in admins:
            logs[&#34;ban_logs&#34;].update(int(text[1]), text[2])
            self.FileLoader().update_csv(self.prefix+&#34;banned&#34;, logs[&#34;ban_logs&#34;].data)
            return {&#34;answer&#34;: &#34;Пользователь забанен&#34;}
        return {&#34;answer&#34;: False}

    def unban(self, peer_id, text, admins, logs):
        &#34;&#34;&#34;
        Разбан пользователя

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower().split(&#39; &#39;)
        if text[0] == &#39;unban&#39; and peer_id in admins:
            user_id = int(text[1])
            if not len(logs[&#34;ban_logs&#34;].data[logs[&#34;ban_logs&#34;].data[&#34;user_id&#34;] == user_id].values):
                return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} не был забанен&#34;}
            logs[&#39;ban_logs&#39;].clear(conditions={&#39;user_id&#39;: user_id})
            self.FileLoader().update_csv(self.prefix+&#34;banned&#34;, logs[&#34;ban_logs&#34;].data)
            return {&#34;answer&#34;: &#34;Пользователь разбанен&#34;}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def registration(self, peer_id: int, text: str, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Регистрация пользователя (установка курса и группы пользователя)

        Пользователь не сможет пройти регистрацию, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

            По ключу &#34;keyboard&#34; хранится клавиатура для сообщения
        &#34;&#34;&#34;
        text = text.lower()
        if peer_id not in list(logs[&#39;users_groups&#39;].data[&#39;user_id&#39;]) or &#39;изменить данные&#39; == text:
            logs[&#39;users_groups&#39;].clear(conditions={&#39;user_id&#39;: peer_id})
            if self.__answers.get(peer_id) is None or text == &#34;изменить данные&#34;:
                text = &#34;изменить данные&#34;
                self.__answers.update({peer_id: [text]})
                return {&#34;answer&#34;: &#34;Приветствую! Для продолжения пройдите краткую регистрацию\nВыберите курс&#34;,
                        &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix + &#34;courses_keyboard.json&#34;),
                        &#34;last_messages&#34;: self.__answers}

            elif self.__answers[peer_id][0] == &#34;изменить данные&#34; and len(self.__answers[peer_id]) == 1:
                if text in self.Messages().get_courses():
                    self.__answers[peer_id].append(text)
                    course_number = int(self.__answers[peer_id][1][0])
                    return {&#34;answer&#34;: &#34;Выберите группу&#34;,
                            &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix + f&#34;course{course_number}_keyboard.json&#34;),
                            &#34;last_messages&#34;: self.__answers}
                else:
                    return {&#34;answer&#34;: &#34;Для продолжения выберите курс&#34;,
                            &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix + &#34;courses_keyboard.json&#34;),
                            &#34;last_messages&#34;: self.__answers}
            elif len(self.__answers[peer_id]) == 2:
                course_number = int(self.__answers[peer_id][1][0])
                if text in self.Messages().get_groups()[course_number - 1]:
                    logs[&#39;users_groups&#39;].update(peer_id, self.__answers[peer_id][1], text)
                    self.FileLoader().update_csv(self.prefix+&#34;users_data&#34;, logs[&#34;users_groups&#34;].data)
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#39;Вы успешно прошли регистрацию. Для изменения данных введите &#34;Изменить данные&#34;&#39;,
                            &#34;last_messages&#34;: self.__answers}
                else:
                    return {&#34;answer&#34;: &#34;Для продолжения выберите группу&#34;,
                            &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix + f&#34;course{course_number}_keyboard.json&#34;),
                            &#34;last_messages&#34;: self.__answers}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def teach_bot(self, peer_id: int, text: str, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Обучение бота новым фразам

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений
        &#34;&#34;&#34;
        if text.lower() == &#34;обучить бота&#34;:
            self.__answers.update({peer_id: [text.lower()]})
            return {&#34;answer&#34;: &#34;Напишите фразу, на которую бот будет отвечать&#34;,
                    &#34;last_messages&#34;: self.__answers}
        elif self.__answers.get(peer_id) is not None:
            if len(self.__answers[peer_id]) == 1 and self.__answers[peer_id][0] == &#34;обучить бота&#34;:
                filtered = BadWordsFilter().filtered(text)
                if filtered != text:
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#34;Нельзя обучать бота мату&#34;,
                            &#34;last_messages&#34;: self.__answers}
                text = text.lower()
                custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
                if text in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#34;Этой фразе бот уже обучен&#34;,
                            &#34;last_messages&#34;: self.__answers}
                elif not self.Messages().is_in_reserve(text):
                    self.__answers[peer_id].append(text)
                    return {&#34;answer&#34;: &#34;Напишите фразу, которой бот будет отвечать на введённую вами ранее&#34;,
                            &#34;last_messages&#34;: self.__answers}
                else:
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#34;Эта фраза зарезервирована, выберите другую&#34;,
                            &#34;last_messages&#34;: self.__answers}
            if len(self.__answers[peer_id]) == 2 and self.__answers[peer_id][0] == &#34;обучить бота&#34;:
                filtered = BadWordsFilter().filtered(text)
                if filtered != text:
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#34;Нельзя обучать бота мату&#34;,
                            &#34;last_messages&#34;: self.__answers}
                self.__answers[peer_id].append(text)
                time_ = datetime.datetime.now()
                Q, A = self.__answers[peer_id][1], self.__answers[peer_id][2]
                logs[&#39;teach&#39;].update(peer_id, Q, A, time_)
                self.FileLoader().update_csv(self.prefix+&#34;teach&#34;, logs[&#34;teach&#34;].data)
                self.__answers[peer_id].clear()
                return {&#34;answer&#34;: &#34;Вы успешно обучили бота&#34;,
                        &#34;last_messages&#34;: self.__answers}
        return {&#34;answer&#34;: False}

    def save_now(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Функция для выгрузки логов на диск по команде

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        if text == &#39;выгрузить логи&#39; and peer_id in admins:
            self.Saver().upload_files(logs, now=True)
            return {&#34;answer&#34;: &#34;Логи выгружены на диск&#34;}
        return {&#34;answer&#34;: False}

    def get_answer(self, peer_id, text, name, surname, course, group, admins, logs):
        &#34;&#34;&#34;
        Получения ответа на сообщение

        Функция последовательно вызывает методы класса, когда какой-то метод вернул ответ != False, функция останавливается
        и возвращает этот ответ

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        name: str
            Имя пользователя
        surname: str
            Фамилия пользователя
        course: str
            Номер курса
        group: int
            Номер группы
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

            По ключу &#34;keyboard&#34; хранится клавиатура для сообщения

            По ключу &#34;photo_file&#34; хранится название jpg файла с графиком

            По ключу &#34;photo_link&#34; хранится bool переменная, если True - в &#34;answer&#34; ссылка на изображение
        &#34;&#34;&#34;
        answer_teach = self.teach_bot(peer_id, text, logs)
        if answer_teach.get(&#34;answer&#34;):
            return answer_teach
        answer_photo = self.get_answer_photo(peer_id, text)
        if answer_photo.get(&#34;answer&#34;):
            return answer_photo
        answer_command = self.get_answer_command(peer_id, text)
        if answer_command.get(&#34;answer&#34;):
            return answer_command
        answer_text = self.get_answer_text(peer_id, text)
        if answer_text.get(&#34;answer&#34;):
            return answer_text
        answer_links = self.get_answer_links(peer_id, text, course)
        if answer_links.get(&#34;answer&#34;):
            return answer_links
        answer_schedule = self.get_answer_schedule(peer_id, text, course, group)
        if answer_schedule.get(&#34;answer&#34;):
            return answer_schedule
        answer_teacher_info = self.get_teacher_info(peer_id, text, name, surname, admins)
        if answer_teacher_info.get(&#34;answer&#34;):
            return answer_teacher_info
        answer_query = self.get_answer_query(peer_id, text)
        if answer_query.get(&#34;answer&#34;):
            return answer_query
        answer_graph = self.get_answer_graph(peer_id, text)
        if answer_graph.get(&#34;answer&#34;):
            return answer_graph
        answer_code = self.get_answer_code(peer_id, text)
        if answer_code.get(&#34;answer&#34;):
            return answer_code
        answer_add_to_whitelist = self.add_to_whitelist(peer_id, text, admins, logs)
        if answer_add_to_whitelist.get(&#34;answer&#34;):
            return answer_add_to_whitelist
        answer_delete_from_whitelist = self.delete_from_whitelist(peer_id, text, admins, logs)
        if answer_delete_from_whitelist.get(&#34;answer&#34;):
            return answer_delete_from_whitelist
        answer_registration = self.registration(peer_id, text, logs)
        if answer_registration.get(&#34;answer&#34;):
            return answer_registration
        answer_ban = self.ban(peer_id, text, admins, logs)
        if answer_ban.get(&#34;answer&#34;):
            return answer_ban
        answer_unban = self.unban(peer_id, text, admins, logs)
        if answer_unban.get(&#34;answer&#34;):
            return answer_unban
        answer_delete_text = self.delete_answer_text(peer_id, text, admins, logs)
        if answer_delete_text.get(&#34;answer&#34;):
            return answer_delete_text
        answer_save_now = self.save_now(peer_id, text, admins, logs)
        if answer_save_now.get(&#34;answer&#34;):
            return answer_save_now
        return {&#34;answer&#34;: False}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Commander.Answerer"><code class="flex name class">
<span>class <span class="ident">Answerer</span></span>
<span>(</span><span>answers=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Класс для получения ответа на полученное сообщение</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>FileLoader</code></strong></dt>
<dd>Класс для доступа к файлам и их обновления</dd>
<dt><strong><code>Links</code></strong></dt>
<dd>Класс для получения ссылок на занятия из файла</dd>
<dt><strong><code>Schedule</code></strong></dt>
<dd>Класс для получения расписания</dd>
<dt><strong><code>Messages</code></strong></dt>
<dd>Класс для хранения и получения зарезервированных ответов и сообщений</dd>
<dt><strong><code>Storage</code></strong></dt>
<dd>Класс для взаимодействия с файлами в хранилище</dd>
<dt><strong><code>QueryResponder</code></strong></dt>
<dd>Класс для ответа на запросы</dd>
<dt><strong><code>GraphBuilder</code></strong></dt>
<dd>Класс для построения графиков</dd>
<dt><strong><code>Keyboard</code></strong></dt>
<dd>Класс клавиатуры</dd>
<dt><strong><code>Saver</code></strong></dt>
<dd>Класс для логирования</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>Префикс для названия файлов клавиатур и логов</dd>
<dt><strong><code>__answers</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Словарь последних сообщений для запоминания предыдущих ответов</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Answerer:
    &#34;&#34;&#34;Класс для получения ответа на полученное сообщение

    Attributes
    ----------
    FileLoader
        Класс для доступа к файлам и их обновления
    Links
        Класс для получения ссылок на занятия из файла
    Schedule
        Класс для получения расписания
    Messages
        Класс для хранения и получения зарезервированных ответов и сообщений
    Storage
        Класс для взаимодействия с файлами в хранилище
    QueryResponder
        Класс для ответа на запросы
    GraphBuilder
        Класс для построения графиков
    Keyboard
        Класс клавиатуры
    Saver
        Класс для логирования
    prefix: str
        Префикс для названия файлов клавиатур и логов
    __answers: dict, default None
        Словарь последних сообщений для запоминания предыдущих ответов
    &#34;&#34;&#34;
    def __init__(self, answers=None):
        if answers is None:
            answers = {}
        self.__answers = answers
        self.FileLoader = Configuration.FileLoader
        self.Links = Configuration.Links
        self.Schedule = Configuration.Schedule
        self.Messages = Configuration.Messages
        self.Storage = Configuration.Storage
        self.QueryResponder = Configuration.QueryResponder
        self.GraphBuilder = Configuration.GraphBuilder
        self.Keyboard = Configuration.Keyboard
        self.prefix = Configuration.prefix
        self.Saver = Configuration.Saver

    def get_teacher_info(self, peer_id: int, text: str, name: str, surname: str, admins: list) -&gt; dict:
        &#34;&#34;&#34;
        Получение информации о пользователе, обучившего бота

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        name: str
            Имя пользователя
        surname: str
            Фамилия пользователя
        admins: list
            Список id администраторов

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;who added &#34;)
        if text[:prefix_size] == &#34;who added &#34; and peer_id in admins:
            phrase = text[prefix_size:]
            custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
            if phrase in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
                customer_id = int(self.Messages(custom=custom_file).get_teacher_id(phrase))
                answer = self.Messages(custom=custom_file).get_answer_custom(phrase)
                if surname is None:
                    surname = &#34;None&#34;
                return {&#34;answer&#34;: (&#39;Имя: &#39; + name + &#39;\n&#39; +
                                   &#39;Фамилия: &#39; + surname + &#39;\n&#39; +
                                   &#39;id: &#39; + str(customer_id) + &#39;\n&#39; +
                                   &#34;Установленный ответ на сообщение: &#34; + answer)}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_command(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение ответа на команду

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        commands_file = self.FileLoader(self.Storage).get_csv(file_name=&#39;commands&#39;)
        if text in list(self.Messages(commands=commands_file).commands):
            return {&#34;answer&#34;: self.Messages(commands=commands_file).get_answer_command(text)}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_links(self, peer_id: int, text: str, course: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение ссылки на занятие

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        course: str
            Номер курса

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

            По ключу &#34;keyboard&#34; хранится клавиатура для сообщения
        &#34;&#34;&#34;
        text = text.lower()
        if course is None:
            return {&#34;answer&#34;: False}
        if text == &#39;лекции&#39;:
            self.__answers.update({peer_id: [text]})
            return {&#34;last_messages&#34;: self.__answers,
                    &#34;answer&#34;: &#39;Выберите предмет:&#39;,
                    &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix+f&#34;lectures_keyboard{course}.json&#34;)}
        links_file = self.FileLoader(self.Storage).get_csv(file_name=f&#39;{course} курс&#39;, folder_name=&#39;Ссылки на занятия&#39;)
        if text in self.Links(links_file).get_subj_list() and self.__answers.get(peer_id) is not None:
            if len(self.__answers[peer_id]):
                if self.__answers[peer_id][0] == &#39;лекции&#39;:
                    self.__answers[peer_id].clear()
                    return {&#34;last_messages&#34;: self.__answers, &#34;answer&#34;: self.Links(links_file).get_subj_link(text)}
        return {&#34;last_messages&#34;: self.__answers, &#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_schedule(self, peer_id: int, text: str, course: str, group: int) -&gt; dict:
        &#34;&#34;&#34;
        Получение расписания

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        course: str
            Номер курса
        group: int
            Номер группы

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

            По ключу &#34;keyboard&#34; хранится клавиатура для сообщения
        &#34;&#34;&#34;
        text = text.lower()
        if course is None or group is None:
            return {&#34;answer&#34;: False}
        if text == &#39;расписание&#39;:
            self.__answers.update({peer_id: [text]})
            return {&#34;last_messages&#34;: self.__answers,
                    &#34;answer&#34;: &#39;Выберите день недели:&#39;,
                    &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix+&#34;days_keyboard.json&#34;)}
        schedule_file = self.FileLoader(self.Storage).get_excel(file_name=&#39;Raspisanie_VESNA_2021&#39;)
        if text in self.Messages().get_days() and self.__answers.get(peer_id) is not None:
            if len(self.__answers[peer_id]):
                if self.__answers[peer_id][0] == &#39;расписание&#39;:
                    self.__answers[peer_id].clear()
                    return {&#34;last_messages&#34;: self.__answers,
                            &#34;answer&#34;: self.Schedule(self.Messages, schedule_file).get_schedule_str(f&#39;{course} курс&#39;, group, text)}
        return {&#34;last_messages&#34;: self.__answers, &#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_text(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение ответа на текстовое сообщение

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
        if text in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
            return {&#34;answer&#34;: self.Messages(custom=custom_file).get_answer_custom(text)}
        return {&#34;answer&#34;: False}

    def delete_answer_text(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Удаление установленного пользователем ответа на сообщение

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;delete &#34;)
        if text[:prefix_size] == &#34;delete &#34; and peer_id in admins:
            phrase = text[prefix_size:]
            custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
            if phrase in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
                logs[&#39;teach&#39;].clear(conditions={&#39;Q&#39;: phrase})
                self.FileLoader().update_csv(self.prefix+&#34;teach&#34;, logs[&#34;teach&#34;].data)
                return {&#34;answer&#34;: f&#39;Ответ на сообщение &#34;{phrase}&#34; удален&#39;}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_photo(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение изображения в ответ на текстовое сообщение

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;photo_link&#34; хранится bool переменная, если True - в &#34;answer&#34; ссылка на изображение
        &#34;&#34;&#34;
        text = text.lower()
        photo_links_file = self.FileLoader(self.Storage).get_csv(file_name=&#39;photo_links&#39;)
        if text in list(self.Messages(photo_links=photo_links_file).photos):
            return {&#34;answer&#34;: self.Messages(photo_links=photo_links_file).get_answer_photo(text), &#34;photo_link&#34;: True}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_query(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение ответа на запрос

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;запрос &#34;)
        if text[:prefix_size] == &#34;запрос &#34;:
            query_text = text[prefix_size:]
            answer = self.QueryResponder().query(query_text)
            if answer:
                return {&#34;answer&#34;: answer}
            else:
                return {&#34;answer&#34;: &#34;Я не смог обработать твой вопрос, задай другой&#34;}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def get_answer_graph(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение графика функции

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя, не используется в функции, но нужен для проверки наличия бана у пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;photo_file&#34; хранится название jpg файла с графиком
        &#34;&#34;&#34;
        try:
            text = text.lower()
            prefix_size = len(&#34;график &#34;)
            if text[:prefix_size] == &#34;график &#34;:
                dimension = text[prefix_size]
                if not (dimension == &#39;2&#39; or dimension == &#39;3&#39;):
                    return {&#34;answer&#34;: &#34;Неверная размерность&#34;}
                func = text[10:]
                self.GraphBuilder().save_plot(func, int(dimension), &#39;graph&#39;)
                return {&#34;answer&#34;: f&#34;График функции {func}&#34;, &#34;photo_file&#34;: &#34;graph.jpg&#34;}
            return {&#34;answer&#34;: False}
        except KeyError:
            return {&#34;answer&#34;: &#34;Я не смог построить этот график, попробуй другой&#34;}

    @AccessLimiter.whitelist_check(Configuration)
    def get_answer_code(self, peer_id: int, text: str) -&gt; dict:
        &#34;&#34;&#34;
        Получение результата выполнения кода

        Функция доступна только пользователям в whitelist&#39;е

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        prefix_size = len(&#34;code &#34;)
        if text[:prefix_size] == &#34;code &#34;:
            language = text[prefix_size:]
            if not (language == &#39;php&#39; or language == &#39;python&#39;):
                return {&#34;answer&#34;: &#34;Выполнять программы на этом языке я не умею&#34;}
            text = &#34;code&#34;
            self.__answers.update({peer_id: [text]})
            self.__answers[peer_id].append(language)
            return {&#34;answer&#34;: f&#34;Введите код на {language} (для питона отступы пишите через \\t)&#34;,
                    &#34;last_messages&#34;: self.__answers}

        elif self.__answers.get(peer_id) is not None:
            if len(self.__answers[peer_id]) == 2 and self.__answers[peer_id][0] == &#34;code&#34;:
                self.__answers[peer_id].append(text)
                return {&#34;answer&#34;: &#34;Введите аргументы для программы через пробел (если аргументов нет введите no args&#34;,
                        &#34;last_messages&#34;: self.__answers}

            if len(self.__answers[peer_id]) == 3 and self.__answers[peer_id][0] == &#34;code&#34;:
                self.__answers[peer_id].append(text)
                if text == &#39;no args&#39;:
                    args = &#39;&#39;
                else:
                    args = self.__answers[peer_id][3]
                language, code = self.__answers[peer_id][1], self.__answers[peer_id][2]
                if language == &#39;php&#39;:
                    prefix, type_ = &#39;&lt;?php\n&#39;, &#39;.php&#39;
                else:
                    language = Configuration.python_version
                    prefix, type_ = &#39;import sys\n&#39;, &#39;.py&#39;
                executor = Interpreter(language, type_, prefix)
                result = executor.execute_code(code, args)
                self.__answers[peer_id].clear()
                if not result:
                    return {&#34;answer&#34;: &#34;Программа вернула пустую строку&#34;}
                else:
                    return {&#34;answer&#34;: result, &#34;last_messages&#34;: self.__answers}
        return {&#34;answer&#34;: False}

    def add_to_whitelist(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Добавления пользователя в whitelist

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;whitelist add &#34;)
        if text[:prefix_size] == &#34;whitelist add &#34; and peer_id in admins:
            user_id = int(text[prefix_size:])
            logs[&#34;whitelist&#34;].update(user_id)
            self.FileLoader().update_csv(self.prefix+&#34;whitelist&#34;, logs[&#34;whitelist&#34;].data)
            return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} добавлен в whitelist&#34;}
        return {&#34;answer&#34;: False}

    def delete_from_whitelist(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Удаление пользователя из whitelist

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        prefix_size = len(&#34;whitelist delete &#34;)
        if text[:prefix_size] == &#34;whitelist delete &#34; and peer_id in admins:
            user_id = int(text[prefix_size:])
            if not len(logs[&#34;whitelist&#34;].data[logs[&#34;whitelist&#34;].data[&#34;user_id&#34;] == user_id].values):
                return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} не был в whitelist&#39;е&#34;}
            logs[&#39;whitelist&#39;].clear(conditions={&#39;user_id&#39;: user_id})
            self.FileLoader().update_csv(self.prefix+&#34;whitelist&#34;, logs[&#34;whitelist&#34;].data)
            return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} удален из whitelist&#39;a&#34;}
        return {&#34;answer&#34;: False}

    def ban(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Добавления пользователя в ban list

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower().split(&#39; &#39;)
        if text[0] == &#39;ban&#39; and peer_id in admins:
            logs[&#34;ban_logs&#34;].update(int(text[1]), text[2])
            self.FileLoader().update_csv(self.prefix+&#34;banned&#34;, logs[&#34;ban_logs&#34;].data)
            return {&#34;answer&#34;: &#34;Пользователь забанен&#34;}
        return {&#34;answer&#34;: False}

    def unban(self, peer_id, text, admins, logs):
        &#34;&#34;&#34;
        Разбан пользователя

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower().split(&#39; &#39;)
        if text[0] == &#39;unban&#39; and peer_id in admins:
            user_id = int(text[1])
            if not len(logs[&#34;ban_logs&#34;].data[logs[&#34;ban_logs&#34;].data[&#34;user_id&#34;] == user_id].values):
                return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} не был забанен&#34;}
            logs[&#39;ban_logs&#39;].clear(conditions={&#39;user_id&#39;: user_id})
            self.FileLoader().update_csv(self.prefix+&#34;banned&#34;, logs[&#34;ban_logs&#34;].data)
            return {&#34;answer&#34;: &#34;Пользователь разбанен&#34;}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def registration(self, peer_id: int, text: str, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Регистрация пользователя (установка курса и группы пользователя)

        Пользователь не сможет пройти регистрацию, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

            По ключу &#34;keyboard&#34; хранится клавиатура для сообщения
        &#34;&#34;&#34;
        text = text.lower()
        if peer_id not in list(logs[&#39;users_groups&#39;].data[&#39;user_id&#39;]) or &#39;изменить данные&#39; == text:
            logs[&#39;users_groups&#39;].clear(conditions={&#39;user_id&#39;: peer_id})
            if self.__answers.get(peer_id) is None or text == &#34;изменить данные&#34;:
                text = &#34;изменить данные&#34;
                self.__answers.update({peer_id: [text]})
                return {&#34;answer&#34;: &#34;Приветствую! Для продолжения пройдите краткую регистрацию\nВыберите курс&#34;,
                        &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix + &#34;courses_keyboard.json&#34;),
                        &#34;last_messages&#34;: self.__answers}

            elif self.__answers[peer_id][0] == &#34;изменить данные&#34; and len(self.__answers[peer_id]) == 1:
                if text in self.Messages().get_courses():
                    self.__answers[peer_id].append(text)
                    course_number = int(self.__answers[peer_id][1][0])
                    return {&#34;answer&#34;: &#34;Выберите группу&#34;,
                            &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix + f&#34;course{course_number}_keyboard.json&#34;),
                            &#34;last_messages&#34;: self.__answers}
                else:
                    return {&#34;answer&#34;: &#34;Для продолжения выберите курс&#34;,
                            &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix + &#34;courses_keyboard.json&#34;),
                            &#34;last_messages&#34;: self.__answers}
            elif len(self.__answers[peer_id]) == 2:
                course_number = int(self.__answers[peer_id][1][0])
                if text in self.Messages().get_groups()[course_number - 1]:
                    logs[&#39;users_groups&#39;].update(peer_id, self.__answers[peer_id][1], text)
                    self.FileLoader().update_csv(self.prefix+&#34;users_data&#34;, logs[&#34;users_groups&#34;].data)
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#39;Вы успешно прошли регистрацию. Для изменения данных введите &#34;Изменить данные&#34;&#39;,
                            &#34;last_messages&#34;: self.__answers}
                else:
                    return {&#34;answer&#34;: &#34;Для продолжения выберите группу&#34;,
                            &#34;keyboard&#34;: self.Keyboard.json_to_keyboard(self.prefix + f&#34;course{course_number}_keyboard.json&#34;),
                            &#34;last_messages&#34;: self.__answers}
        return {&#34;answer&#34;: False}

    @AccessLimiter.ban_check(Configuration)
    def teach_bot(self, peer_id: int, text: str, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Обучение бота новым фразам

        Пользователь не сможет получить ответ на сообщение, если у него будет забанена функция

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений
        &#34;&#34;&#34;
        if text.lower() == &#34;обучить бота&#34;:
            self.__answers.update({peer_id: [text.lower()]})
            return {&#34;answer&#34;: &#34;Напишите фразу, на которую бот будет отвечать&#34;,
                    &#34;last_messages&#34;: self.__answers}
        elif self.__answers.get(peer_id) is not None:
            if len(self.__answers[peer_id]) == 1 and self.__answers[peer_id][0] == &#34;обучить бота&#34;:
                filtered = BadWordsFilter().filtered(text)
                if filtered != text:
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#34;Нельзя обучать бота мату&#34;,
                            &#34;last_messages&#34;: self.__answers}
                text = text.lower()
                custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
                if text in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#34;Этой фразе бот уже обучен&#34;,
                            &#34;last_messages&#34;: self.__answers}
                elif not self.Messages().is_in_reserve(text):
                    self.__answers[peer_id].append(text)
                    return {&#34;answer&#34;: &#34;Напишите фразу, которой бот будет отвечать на введённую вами ранее&#34;,
                            &#34;last_messages&#34;: self.__answers}
                else:
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#34;Эта фраза зарезервирована, выберите другую&#34;,
                            &#34;last_messages&#34;: self.__answers}
            if len(self.__answers[peer_id]) == 2 and self.__answers[peer_id][0] == &#34;обучить бота&#34;:
                filtered = BadWordsFilter().filtered(text)
                if filtered != text:
                    self.__answers[peer_id].clear()
                    return {&#34;answer&#34;: &#34;Нельзя обучать бота мату&#34;,
                            &#34;last_messages&#34;: self.__answers}
                self.__answers[peer_id].append(text)
                time_ = datetime.datetime.now()
                Q, A = self.__answers[peer_id][1], self.__answers[peer_id][2]
                logs[&#39;teach&#39;].update(peer_id, Q, A, time_)
                self.FileLoader().update_csv(self.prefix+&#34;teach&#34;, logs[&#34;teach&#34;].data)
                self.__answers[peer_id].clear()
                return {&#34;answer&#34;: &#34;Вы успешно обучили бота&#34;,
                        &#34;last_messages&#34;: self.__answers}
        return {&#34;answer&#34;: False}

    def save_now(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
        &#34;&#34;&#34;
        Функция для выгрузки логов на диск по команде

        Функция доступна только администраторам

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
        &#34;&#34;&#34;
        text = text.lower()
        if text == &#39;выгрузить логи&#39; and peer_id in admins:
            self.Saver().upload_files(logs, now=True)
            return {&#34;answer&#34;: &#34;Логи выгружены на диск&#34;}
        return {&#34;answer&#34;: False}

    def get_answer(self, peer_id, text, name, surname, course, group, admins, logs):
        &#34;&#34;&#34;
        Получения ответа на сообщение

        Функция последовательно вызывает методы класса, когда какой-то метод вернул ответ != False, функция останавливается
        и возвращает этот ответ

        Parameters
        ----------
        peer_id: int
            id пользователя
        text: str
            Текст сообщения
        name: str
            Имя пользователя
        surname: str
            Фамилия пользователя
        course: str
            Номер курса
        group: int
            Номер группы
        admins: list
            Список id администраторов
        logs: dict
            Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

        Returns
        -------
        dict
            Словарь с ответом

            По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

            По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

            По ключу &#34;keyboard&#34; хранится клавиатура для сообщения

            По ключу &#34;photo_file&#34; хранится название jpg файла с графиком

            По ключу &#34;photo_link&#34; хранится bool переменная, если True - в &#34;answer&#34; ссылка на изображение
        &#34;&#34;&#34;
        answer_teach = self.teach_bot(peer_id, text, logs)
        if answer_teach.get(&#34;answer&#34;):
            return answer_teach
        answer_photo = self.get_answer_photo(peer_id, text)
        if answer_photo.get(&#34;answer&#34;):
            return answer_photo
        answer_command = self.get_answer_command(peer_id, text)
        if answer_command.get(&#34;answer&#34;):
            return answer_command
        answer_text = self.get_answer_text(peer_id, text)
        if answer_text.get(&#34;answer&#34;):
            return answer_text
        answer_links = self.get_answer_links(peer_id, text, course)
        if answer_links.get(&#34;answer&#34;):
            return answer_links
        answer_schedule = self.get_answer_schedule(peer_id, text, course, group)
        if answer_schedule.get(&#34;answer&#34;):
            return answer_schedule
        answer_teacher_info = self.get_teacher_info(peer_id, text, name, surname, admins)
        if answer_teacher_info.get(&#34;answer&#34;):
            return answer_teacher_info
        answer_query = self.get_answer_query(peer_id, text)
        if answer_query.get(&#34;answer&#34;):
            return answer_query
        answer_graph = self.get_answer_graph(peer_id, text)
        if answer_graph.get(&#34;answer&#34;):
            return answer_graph
        answer_code = self.get_answer_code(peer_id, text)
        if answer_code.get(&#34;answer&#34;):
            return answer_code
        answer_add_to_whitelist = self.add_to_whitelist(peer_id, text, admins, logs)
        if answer_add_to_whitelist.get(&#34;answer&#34;):
            return answer_add_to_whitelist
        answer_delete_from_whitelist = self.delete_from_whitelist(peer_id, text, admins, logs)
        if answer_delete_from_whitelist.get(&#34;answer&#34;):
            return answer_delete_from_whitelist
        answer_registration = self.registration(peer_id, text, logs)
        if answer_registration.get(&#34;answer&#34;):
            return answer_registration
        answer_ban = self.ban(peer_id, text, admins, logs)
        if answer_ban.get(&#34;answer&#34;):
            return answer_ban
        answer_unban = self.unban(peer_id, text, admins, logs)
        if answer_unban.get(&#34;answer&#34;):
            return answer_unban
        answer_delete_text = self.delete_answer_text(peer_id, text, admins, logs)
        if answer_delete_text.get(&#34;answer&#34;):
            return answer_delete_text
        answer_save_now = self.save_now(peer_id, text, admins, logs)
        if answer_save_now.get(&#34;answer&#34;):
            return answer_save_now
        return {&#34;answer&#34;: False}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Commander.Answerer.add_to_whitelist"><code class="name flex">
<span>def <span class="ident">add_to_whitelist</span></span>(<span>self, peer_id: int, text: str, admins: list, logs: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Добавления пользователя в whitelist</p>
<p>Функция доступна только администраторам</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>id пользователя</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Текст сообщения</dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>list</code></dt>
<dd>Список id администраторов</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Словарь с ответом</p>
<p>По ключу "answer" хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_whitelist(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
    &#34;&#34;&#34;
    Добавления пользователя в whitelist

    Функция доступна только администраторам

    Parameters
    ----------
    peer_id: int
        id пользователя
    text: str
        Текст сообщения
    admins: list
        Список id администраторов
    logs: dict
        Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

    Returns
    -------
    dict
        Словарь с ответом

        По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
    &#34;&#34;&#34;
    text = text.lower()
    prefix_size = len(&#34;whitelist add &#34;)
    if text[:prefix_size] == &#34;whitelist add &#34; and peer_id in admins:
        user_id = int(text[prefix_size:])
        logs[&#34;whitelist&#34;].update(user_id)
        self.FileLoader().update_csv(self.prefix+&#34;whitelist&#34;, logs[&#34;whitelist&#34;].data)
        return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} добавлен в whitelist&#34;}
    return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.ban"><code class="name flex">
<span>def <span class="ident">ban</span></span>(<span>self, peer_id: int, text: str, admins: list, logs: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Добавления пользователя в ban list</p>
<p>Функция доступна только администраторам</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>id пользователя</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Текст сообщения</dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>list</code></dt>
<dd>Список id администраторов</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Словарь с ответом</p>
<p>По ключу "answer" хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ban(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
    &#34;&#34;&#34;
    Добавления пользователя в ban list

    Функция доступна только администраторам

    Parameters
    ----------
    peer_id: int
        id пользователя
    text: str
        Текст сообщения
    admins: list
        Список id администраторов
    logs: dict
        Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

    Returns
    -------
    dict
        Словарь с ответом

        По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
    &#34;&#34;&#34;
    text = text.lower().split(&#39; &#39;)
    if text[0] == &#39;ban&#39; and peer_id in admins:
        logs[&#34;ban_logs&#34;].update(int(text[1]), text[2])
        self.FileLoader().update_csv(self.prefix+&#34;banned&#34;, logs[&#34;ban_logs&#34;].data)
        return {&#34;answer&#34;: &#34;Пользователь забанен&#34;}
    return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.delete_answer_text"><code class="name flex">
<span>def <span class="ident">delete_answer_text</span></span>(<span>self, peer_id: int, text: str, admins: list, logs: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Удаление установленного пользователем ответа на сообщение</p>
<p>Функция доступна только администраторам</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>id пользователя</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Текст сообщения</dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>list</code></dt>
<dd>Список id администраторов</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Словарь с ответом</p>
<p>По ключу "answer" хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_answer_text(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
    &#34;&#34;&#34;
    Удаление установленного пользователем ответа на сообщение

    Функция доступна только администраторам

    Parameters
    ----------
    peer_id: int
        id пользователя
    text: str
        Текст сообщения
    admins: list
        Список id администраторов
    logs: dict
        Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

    Returns
    -------
    dict
        Словарь с ответом

        По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
    &#34;&#34;&#34;
    text = text.lower()
    prefix_size = len(&#34;delete &#34;)
    if text[:prefix_size] == &#34;delete &#34; and peer_id in admins:
        phrase = text[prefix_size:]
        custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
        if phrase in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
            logs[&#39;teach&#39;].clear(conditions={&#39;Q&#39;: phrase})
            self.FileLoader().update_csv(self.prefix+&#34;teach&#34;, logs[&#34;teach&#34;].data)
            return {&#34;answer&#34;: f&#39;Ответ на сообщение &#34;{phrase}&#34; удален&#39;}
    return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.delete_from_whitelist"><code class="name flex">
<span>def <span class="ident">delete_from_whitelist</span></span>(<span>self, peer_id: int, text: str, admins: list, logs: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Удаление пользователя из whitelist</p>
<p>Функция доступна только администраторам</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>id пользователя</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Текст сообщения</dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>list</code></dt>
<dd>Список id администраторов</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Словарь с ответом</p>
<p>По ключу "answer" хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_from_whitelist(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
    &#34;&#34;&#34;
    Удаление пользователя из whitelist

    Функция доступна только администраторам

    Parameters
    ----------
    peer_id: int
        id пользователя
    text: str
        Текст сообщения
    admins: list
        Список id администраторов
    logs: dict
        Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

    Returns
    -------
    dict
        Словарь с ответом

        По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
    &#34;&#34;&#34;
    text = text.lower()
    prefix_size = len(&#34;whitelist delete &#34;)
    if text[:prefix_size] == &#34;whitelist delete &#34; and peer_id in admins:
        user_id = int(text[prefix_size:])
        if not len(logs[&#34;whitelist&#34;].data[logs[&#34;whitelist&#34;].data[&#34;user_id&#34;] == user_id].values):
            return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} не был в whitelist&#39;е&#34;}
        logs[&#39;whitelist&#39;].clear(conditions={&#39;user_id&#39;: user_id})
        self.FileLoader().update_csv(self.prefix+&#34;whitelist&#34;, logs[&#34;whitelist&#34;].data)
        return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} удален из whitelist&#39;a&#34;}
    return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer"><code class="name flex">
<span>def <span class="ident">get_answer</span></span>(<span>self, peer_id, text, name, surname, course, group, admins, logs)</span>
</code></dt>
<dd>
<div class="desc"><p>Получения ответа на сообщение</p>
<p>Функция последовательно вызывает методы класса, когда какой-то метод вернул ответ != False, функция останавливается
и возвращает этот ответ</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>id пользователя</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Текст сообщения</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Имя пользователя</dd>
<dt><strong><code>surname</code></strong> :&ensp;<code>str</code></dt>
<dd>Фамилия пользователя</dd>
<dt><strong><code>course</code></strong> :&ensp;<code>str</code></dt>
<dd>Номер курса</dd>
<dt><strong><code>group</code></strong> :&ensp;<code>int</code></dt>
<dd>Номер группы</dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>list</code></dt>
<dd>Список id администраторов</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Словарь с ответом</p>
<p>По ключу "answer" хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе</p>
<p>По ключу "last_messages" хранится словарь сохраненных сообщений</p>
<p>По ключу "keyboard" хранится клавиатура для сообщения</p>
<p>По ключу "photo_file" хранится название jpg файла с графиком</p>
<p>По ключу "photo_link" хранится bool переменная, если True - в "answer" ссылка на изображение</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_answer(self, peer_id, text, name, surname, course, group, admins, logs):
    &#34;&#34;&#34;
    Получения ответа на сообщение

    Функция последовательно вызывает методы класса, когда какой-то метод вернул ответ != False, функция останавливается
    и возвращает этот ответ

    Parameters
    ----------
    peer_id: int
        id пользователя
    text: str
        Текст сообщения
    name: str
        Имя пользователя
    surname: str
        Фамилия пользователя
    course: str
        Номер курса
    group: int
        Номер группы
    admins: list
        Список id администраторов
    logs: dict
        Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

    Returns
    -------
    dict
        Словарь с ответом

        По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе

        По ключу &#34;last_messages&#34; хранится словарь сохраненных сообщений

        По ключу &#34;keyboard&#34; хранится клавиатура для сообщения

        По ключу &#34;photo_file&#34; хранится название jpg файла с графиком

        По ключу &#34;photo_link&#34; хранится bool переменная, если True - в &#34;answer&#34; ссылка на изображение
    &#34;&#34;&#34;
    answer_teach = self.teach_bot(peer_id, text, logs)
    if answer_teach.get(&#34;answer&#34;):
        return answer_teach
    answer_photo = self.get_answer_photo(peer_id, text)
    if answer_photo.get(&#34;answer&#34;):
        return answer_photo
    answer_command = self.get_answer_command(peer_id, text)
    if answer_command.get(&#34;answer&#34;):
        return answer_command
    answer_text = self.get_answer_text(peer_id, text)
    if answer_text.get(&#34;answer&#34;):
        return answer_text
    answer_links = self.get_answer_links(peer_id, text, course)
    if answer_links.get(&#34;answer&#34;):
        return answer_links
    answer_schedule = self.get_answer_schedule(peer_id, text, course, group)
    if answer_schedule.get(&#34;answer&#34;):
        return answer_schedule
    answer_teacher_info = self.get_teacher_info(peer_id, text, name, surname, admins)
    if answer_teacher_info.get(&#34;answer&#34;):
        return answer_teacher_info
    answer_query = self.get_answer_query(peer_id, text)
    if answer_query.get(&#34;answer&#34;):
        return answer_query
    answer_graph = self.get_answer_graph(peer_id, text)
    if answer_graph.get(&#34;answer&#34;):
        return answer_graph
    answer_code = self.get_answer_code(peer_id, text)
    if answer_code.get(&#34;answer&#34;):
        return answer_code
    answer_add_to_whitelist = self.add_to_whitelist(peer_id, text, admins, logs)
    if answer_add_to_whitelist.get(&#34;answer&#34;):
        return answer_add_to_whitelist
    answer_delete_from_whitelist = self.delete_from_whitelist(peer_id, text, admins, logs)
    if answer_delete_from_whitelist.get(&#34;answer&#34;):
        return answer_delete_from_whitelist
    answer_registration = self.registration(peer_id, text, logs)
    if answer_registration.get(&#34;answer&#34;):
        return answer_registration
    answer_ban = self.ban(peer_id, text, admins, logs)
    if answer_ban.get(&#34;answer&#34;):
        return answer_ban
    answer_unban = self.unban(peer_id, text, admins, logs)
    if answer_unban.get(&#34;answer&#34;):
        return answer_unban
    answer_delete_text = self.delete_answer_text(peer_id, text, admins, logs)
    if answer_delete_text.get(&#34;answer&#34;):
        return answer_delete_text
    answer_save_now = self.save_now(peer_id, text, admins, logs)
    if answer_save_now.get(&#34;answer&#34;):
        return answer_save_now
    return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer_code"><code class="name flex">
<span>def <span class="ident">get_answer_code</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    whitelist_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;whitelist&#34;)
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    whitelist = whitelist_data[&#39;user_id&#39;].values
    if peer_id in whitelist:
        res = func(self, *args, **kwargs)
        if res.get(&#34;answer&#34;):
            return res
        else:
            return {&#34;answer&#34;: False}
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer_command"><code class="name flex">
<span>def <span class="ident">get_answer_command</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer_graph"><code class="name flex">
<span>def <span class="ident">get_answer_graph</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer_links"><code class="name flex">
<span>def <span class="ident">get_answer_links</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer_photo"><code class="name flex">
<span>def <span class="ident">get_answer_photo</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer_query"><code class="name flex">
<span>def <span class="ident">get_answer_query</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer_schedule"><code class="name flex">
<span>def <span class="ident">get_answer_schedule</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_answer_text"><code class="name flex">
<span>def <span class="ident">get_answer_text</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.get_teacher_info"><code class="name flex">
<span>def <span class="ident">get_teacher_info</span></span>(<span>self, peer_id: int, text: str, name: str, surname: str, admins: list) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Получение информации о пользователе, обучившего бота</p>
<p>Функция доступна только администраторам</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>id пользователя</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Текст сообщения</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Имя пользователя</dd>
<dt><strong><code>surname</code></strong> :&ensp;<code>str</code></dt>
<dd>Фамилия пользователя</dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>list</code></dt>
<dd>Список id администраторов</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Словарь с ответом</p>
<p>По ключу "answer" хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_teacher_info(self, peer_id: int, text: str, name: str, surname: str, admins: list) -&gt; dict:
    &#34;&#34;&#34;
    Получение информации о пользователе, обучившего бота

    Функция доступна только администраторам

    Parameters
    ----------
    peer_id: int
        id пользователя
    text: str
        Текст сообщения
    name: str
        Имя пользователя
    surname: str
        Фамилия пользователя
    admins: list
        Список id администраторов

    Returns
    -------
    dict
        Словарь с ответом

        По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
    &#34;&#34;&#34;
    text = text.lower()
    prefix_size = len(&#34;who added &#34;)
    if text[:prefix_size] == &#34;who added &#34; and peer_id in admins:
        phrase = text[prefix_size:]
        custom_file = self.FileLoader(self.Storage).get_csv(self.prefix+&#34;teach&#34;)
        if phrase in list(self.Messages(custom=custom_file).custom[&#39;Q&#39;]):
            customer_id = int(self.Messages(custom=custom_file).get_teacher_id(phrase))
            answer = self.Messages(custom=custom_file).get_answer_custom(phrase)
            if surname is None:
                surname = &#34;None&#34;
            return {&#34;answer&#34;: (&#39;Имя: &#39; + name + &#39;\n&#39; +
                               &#39;Фамилия: &#39; + surname + &#39;\n&#39; +
                               &#39;id: &#39; + str(customer_id) + &#39;\n&#39; +
                               &#34;Установленный ответ на сообщение: &#34; + answer)}
    return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.registration"><code class="name flex">
<span>def <span class="ident">registration</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.save_now"><code class="name flex">
<span>def <span class="ident">save_now</span></span>(<span>self, peer_id: int, text: str, admins: list, logs: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Функция для выгрузки логов на диск по команде</p>
<p>Функция доступна только администраторам</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>id пользователя</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Текст сообщения</dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>list</code></dt>
<dd>Список id администраторов</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Словарь с ответом</p>
<p>По ключу "answer" хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_now(self, peer_id: int, text: str, admins: list, logs: dict) -&gt; dict:
    &#34;&#34;&#34;
    Функция для выгрузки логов на диск по команде

    Функция доступна только администраторам

    Parameters
    ----------
    peer_id: int
        id пользователя
    text: str
        Текст сообщения
    admins: list
        Список id администраторов
    logs: dict
        Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

    Returns
    -------
    dict
        Словарь с ответом

        По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
    &#34;&#34;&#34;
    text = text.lower()
    if text == &#39;выгрузить логи&#39; and peer_id in admins:
        self.Saver().upload_files(logs, now=True)
        return {&#34;answer&#34;: &#34;Логи выгружены на диск&#34;}
    return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.teach_bot"><code class="name flex">
<span>def <span class="ident">teach_bot</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapped(self, *args, **kwargs):
    args_arr = np.array(inspect.getfullargspec(func)[0])
    id_pos = np.argwhere(args_arr == &#39;peer_id&#39;)[0][0]
    peer_id = args[id_pos - 1]
    ban_data = conf.FileLoader(conf.Storage).get_csv(file_name=conf.prefix+&#34;banned&#34;)
    ban_list = ban_data[ban_data[&#39;user_id&#39;] == peer_id][&#39;banned_functions&#39;].values
    res = func(self, *args, **kwargs)
    if res.get(&#34;answer&#34;):
        if func.__name__ in ban_list:
            return {&#34;answer&#34;: &#34;Администрация временно ограничила ваше право пользования этой функцией&#34;}
        else:
            return res
    else:
        return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
<dt id="Commander.Answerer.unban"><code class="name flex">
<span>def <span class="ident">unban</span></span>(<span>self, peer_id, text, admins, logs)</span>
</code></dt>
<dd>
<div class="desc"><p>Разбан пользователя</p>
<p>Функция доступна только администраторам</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>id пользователя</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Текст сообщения</dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>list</code></dt>
<dd>Список id администраторов</dd>
<dt><strong><code>logs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Словарь с ответом</p>
<p>По ключу "answer" хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unban(self, peer_id, text, admins, logs):
    &#34;&#34;&#34;
    Разбан пользователя

    Функция доступна только администраторам

    Parameters
    ----------
    peer_id: int
        id пользователя
    text: str
        Текст сообщения
    admins: list
        Список id администраторов
    logs: dict
        Словарь с объектами класса Logs, хранящий данные о пользователях и сообщениях

    Returns
    -------
    dict
        Словарь с ответом

        По ключу &#34;answer&#34; хранится текстовое сообщение, если на полученное сообщение есть ответ, False иначе
    &#34;&#34;&#34;
    text = text.lower().split(&#39; &#39;)
    if text[0] == &#39;unban&#39; and peer_id in admins:
        user_id = int(text[1])
        if not len(logs[&#34;ban_logs&#34;].data[logs[&#34;ban_logs&#34;].data[&#34;user_id&#34;] == user_id].values):
            return {&#34;answer&#34;: f&#34;Пользователь с id {user_id} не был забанен&#34;}
        logs[&#39;ban_logs&#39;].clear(conditions={&#39;user_id&#39;: user_id})
        self.FileLoader().update_csv(self.prefix+&#34;banned&#34;, logs[&#34;ban_logs&#34;].data)
        return {&#34;answer&#34;: &#34;Пользователь разбанен&#34;}
    return {&#34;answer&#34;: False}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Commander.Answerer" href="#Commander.Answerer">Answerer</a></code></h4>
<ul class="">
<li><code><a title="Commander.Answerer.add_to_whitelist" href="#Commander.Answerer.add_to_whitelist">add_to_whitelist</a></code></li>
<li><code><a title="Commander.Answerer.ban" href="#Commander.Answerer.ban">ban</a></code></li>
<li><code><a title="Commander.Answerer.delete_answer_text" href="#Commander.Answerer.delete_answer_text">delete_answer_text</a></code></li>
<li><code><a title="Commander.Answerer.delete_from_whitelist" href="#Commander.Answerer.delete_from_whitelist">delete_from_whitelist</a></code></li>
<li><code><a title="Commander.Answerer.get_answer" href="#Commander.Answerer.get_answer">get_answer</a></code></li>
<li><code><a title="Commander.Answerer.get_answer_code" href="#Commander.Answerer.get_answer_code">get_answer_code</a></code></li>
<li><code><a title="Commander.Answerer.get_answer_command" href="#Commander.Answerer.get_answer_command">get_answer_command</a></code></li>
<li><code><a title="Commander.Answerer.get_answer_graph" href="#Commander.Answerer.get_answer_graph">get_answer_graph</a></code></li>
<li><code><a title="Commander.Answerer.get_answer_links" href="#Commander.Answerer.get_answer_links">get_answer_links</a></code></li>
<li><code><a title="Commander.Answerer.get_answer_photo" href="#Commander.Answerer.get_answer_photo">get_answer_photo</a></code></li>
<li><code><a title="Commander.Answerer.get_answer_query" href="#Commander.Answerer.get_answer_query">get_answer_query</a></code></li>
<li><code><a title="Commander.Answerer.get_answer_schedule" href="#Commander.Answerer.get_answer_schedule">get_answer_schedule</a></code></li>
<li><code><a title="Commander.Answerer.get_answer_text" href="#Commander.Answerer.get_answer_text">get_answer_text</a></code></li>
<li><code><a title="Commander.Answerer.get_teacher_info" href="#Commander.Answerer.get_teacher_info">get_teacher_info</a></code></li>
<li><code><a title="Commander.Answerer.registration" href="#Commander.Answerer.registration">registration</a></code></li>
<li><code><a title="Commander.Answerer.save_now" href="#Commander.Answerer.save_now">save_now</a></code></li>
<li><code><a title="Commander.Answerer.teach_bot" href="#Commander.Answerer.teach_bot">teach_bot</a></code></li>
<li><code><a title="Commander.Answerer.unban" href="#Commander.Answerer.unban">unban</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>